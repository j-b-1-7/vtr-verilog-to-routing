// ==============================================================
// File generated by AutoESL - High-Level Synthesis System (C, C++, SystemC)
// Version: 2011.1
// Copyright (C) 2011 Xilinx Inc. All rights reserved.
// 
// ==============================================================



`timescale 1 ns / 1 ps




module SURFdescriptor_ys_core (q, ra, ce, clk
);
   parameter READ_PORT_COUNT=32'd1;
   parameter WRITE_PORT_COUNT=32'd1;
   parameter DATA_WIDTH=32'd4;
   parameter ADDRESS_WIDTH=32'd7;
   parameter WORD_COUNT=32'd113;

   output [READ_PORT_COUNT*DATA_WIDTH-1:0] q;
   input [READ_PORT_COUNT*ADDRESS_WIDTH-1:0]  ra;
   input [READ_PORT_COUNT-1:0]  ce;
   input                                      clk;

   integer                                    i,j,k;

   wire [DATA_WIDTH-1:0]                       mem [0:WORD_COUNT-1];
   reg [ADDRESS_WIDTH-1:0]                    rat;
   reg [ADDRESS_WIDTH-1:0]                    rai [READ_PORT_COUNT-1:0];
   reg [ADDRESS_WIDTH-1:0]                    rai_reg [READ_PORT_COUNT-1:0];
   reg [READ_PORT_COUNT*DATA_WIDTH-1:0]       qi;
   reg [DATA_WIDTH-1:0]                       qt;


    assign mem[0] = 4'b1010;
    assign mem[1] = 4'b1011;
    assign mem[2] = 4'b1011;
    assign mem[3] = 4'b1011;
    assign mem[4] = 4'b1011;
    assign mem[5] = 4'b1011;
    assign mem[6] = 4'b1011;
    assign mem[7] = 4'b1011;
    assign mem[8] = 4'b1100;
    assign mem[9] = 4'b1100;
    assign mem[10] = 4'b1100;
    assign mem[11] = 4'b1100;
    assign mem[12] = 4'b1100;
    assign mem[13] = 4'b1100;
    assign mem[14] = 4'b1100;
    assign mem[15] = 4'b1100;
    assign mem[16] = 4'b1100;
    assign mem[17] = 4'b1101;
    assign mem[18] = 4'b1101;
    assign mem[19] = 4'b1101;
    assign mem[20] = 4'b1101;
    assign mem[21] = 4'b1101;
    assign mem[22] = 4'b1101;
    assign mem[23] = 4'b1101;
    assign mem[24] = 4'b1101;
    assign mem[25] = 4'b1101;
    assign mem[26] = 4'b1101;
    assign mem[27] = 4'b1101;
    assign mem[28] = 4'b1110;
    assign mem[29] = 4'b1110;
    assign mem[30] = 4'b1110;
    assign mem[31] = 4'b1110;
    assign mem[32] = 4'b1110;
    assign mem[33] = 4'b1110;
    assign mem[34] = 4'b1110;
    assign mem[35] = 4'b1110;
    assign mem[36] = 4'b1110;
    assign mem[37] = 4'b1110;
    assign mem[38] = 4'b1110;
    assign mem[39] = 4'b1111;
    assign mem[40] = 4'b1111;
    assign mem[41] = 4'b1111;
    assign mem[42] = 4'b1111;
    assign mem[43] = 4'b1111;
    assign mem[44] = 4'b1111;
    assign mem[45] = 4'b1111;
    assign mem[46] = 4'b1111;
    assign mem[47] = 4'b1111;
    assign mem[48] = 4'b1111;
    assign mem[49] = 4'b1111;
    assign mem[50] = 4'b0000;
    assign mem[51] = 4'b0000;
    assign mem[52] = 4'b0000;
    assign mem[53] = 4'b0000;
    assign mem[54] = 4'b0000;
    assign mem[55] = 4'b0000;
    assign mem[56] = 4'b0000;
    assign mem[57] = 4'b0000;
    assign mem[58] = 4'b0000;
    assign mem[59] = 4'b0000;
    assign mem[60] = 4'b0000;
    assign mem[61] = 4'b0000;
    assign mem[62] = 4'b0000;
    assign mem[63] = 4'b0001;
    assign mem[64] = 4'b0001;
    assign mem[65] = 4'b0001;
    assign mem[66] = 4'b0001;
    assign mem[67] = 4'b0001;
    assign mem[68] = 4'b0001;
    assign mem[69] = 4'b0001;
    assign mem[70] = 4'b0001;
    assign mem[71] = 4'b0001;
    assign mem[72] = 4'b0001;
    assign mem[73] = 4'b0001;
    assign mem[74] = 4'b0010;
    assign mem[75] = 4'b0010;
    assign mem[76] = 4'b0010;
    assign mem[77] = 4'b0010;
    assign mem[78] = 4'b0010;
    assign mem[79] = 4'b0010;
    assign mem[80] = 4'b0010;
    assign mem[81] = 4'b0010;
    assign mem[82] = 4'b0010;
    assign mem[83] = 4'b0010;
    assign mem[84] = 4'b0010;
    assign mem[85] = 4'b0011;
    assign mem[86] = 4'b0011;
    assign mem[87] = 4'b0011;
    assign mem[88] = 4'b0011;
    assign mem[89] = 4'b0011;
    assign mem[90] = 4'b0011;
    assign mem[91] = 4'b0011;
    assign mem[92] = 4'b0011;
    assign mem[93] = 4'b0011;
    assign mem[94] = 4'b0011;
    assign mem[95] = 4'b0011;
    assign mem[96] = 4'b0100;
    assign mem[97] = 4'b0100;
    assign mem[98] = 4'b0100;
    assign mem[99] = 4'b0100;
    assign mem[100] = 4'b0100;
    assign mem[101] = 4'b0100;
    assign mem[102] = 4'b0100;
    assign mem[103] = 4'b0100;
    assign mem[104] = 4'b0100;
    assign mem[105] = 4'b0101;
    assign mem[106] = 4'b0101;
    assign mem[107] = 4'b0101;
    assign mem[108] = 4'b0101;
    assign mem[109] = 4'b0101;
    assign mem[110] = 4'b0101;
    assign mem[111] = 4'b0101;
    assign mem[112] = 4'b0110;


   // Split read addresses
   always @ (ra) begin
      for (i=0;i<READ_PORT_COUNT;i=i+1) begin
         for (j=0;j<ADDRESS_WIDTH;j=j+1) begin
            rat[j]=ra[i*ADDRESS_WIDTH+j];
         end
         rai[i]=rat;
      end
   end

   // guide read addresses using CE
   always @ (posedge clk) begin
      for (i=0;i<READ_PORT_COUNT;i=i+1) begin
         if ( ce[i] ) begin
            rai_reg[i] <= rai[i];
         end
      end
   end


   // Memory read
    genvar x;
    generate
        for (x = 0; x < READ_PORT_COUNT; x = x + 1) begin : gen_q
            assign q[x*DATA_WIDTH+DATA_WIDTH-1:x*DATA_WIDTH] = (rai_reg[x]<WORD_COUNT)?
                mem[rai_reg[x]] : {DATA_WIDTH{1'b0}};
        end
    endgenerate

endmodule


module SURFdescriptor_ys (
    address0,
    ce0,
    q0,


    clk);


parameter DataWidth = 32'd4;
parameter AddressRange = 32'd113;
parameter AddressWidth = 32'd7;

input[AddressWidth-1:0] address0;
input ce0;
output[DataWidth-1:0] q0;
input clk;


reg[DataWidth-1:0] q0;
wire[1 * DataWidth - 1:0] mem_q;
wire[DataWidth - 1:0] mem_q0;
wire[1 * AddressWidth - 1:0]  mem_ra;
wire[1 - 1:0]  mem_ce;


SURFdescriptor_ys_core #(
    .READ_PORT_COUNT( 1 ),
    .WRITE_PORT_COUNT( 1 ),
    .DATA_WIDTH( DataWidth ),
    .ADDRESS_WIDTH( AddressWidth ),
    .WORD_COUNT( AddressRange ))
core_inst (
    .q( mem_q ),
    .ra( mem_ra ),
    .ce( mem_ce ),
    .clk( clk ));


assign mem_q0 =  mem_q[1 * DataWidth - 1 : 0 * DataWidth];

always @ (mem_q0) begin
        q0 = mem_q0;
end

assign mem_ra = {address0};
assign mem_ce = {ce0};

endmodule
