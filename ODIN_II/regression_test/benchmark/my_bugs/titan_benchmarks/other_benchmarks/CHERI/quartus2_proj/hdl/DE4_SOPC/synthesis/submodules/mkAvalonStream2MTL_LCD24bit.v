//
// Generated by Bluespec Compiler, version 2012.07.beta1 (build 29243, 2012-07-26)
//
// On Thu Aug 16 11:48:36 BST 2012
//
// Method conflict info:
// Method: asi_stream_in
// Conflict-free: asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
// Conflicts: asi_stream_in
//
// Method: asi_stream_in_ready
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
// Method: coe_tpadlcd_mtl_r
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
// Method: coe_tpadlcd_mtl_g
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
// Method: coe_tpadlcd_mtl_b
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
// Method: coe_tpadlcd_mtl_hsd
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
// Method: coe_tpadlcd_mtl_vsd
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       coe_tpadlcd_mtl_r,
// 	       coe_tpadlcd_mtl_g,
// 	       coe_tpadlcd_mtl_b,
// 	       coe_tpadlcd_mtl_hsd,
// 	       coe_tpadlcd_mtl_vsd
//
//
// Ports:
// Name                         I/O  size props
// asi_stream_in_ready            O     1
// coe_tpadlcd_mtl_r              O     8 reg
// coe_tpadlcd_mtl_g              O     8 reg
// coe_tpadlcd_mtl_b              O     8 reg
// coe_tpadlcd_mtl_hsd            O     1 reg
// coe_tpadlcd_mtl_vsd            O     1 reg
// csi_clockreset_clk             I     1 clock
// csi_clockreset_reset_n         I     1 reset
// asi_stream_in_data             I    24
// asi_stream_in_valid            I     1
// asi_stream_in_startofpacket    I     1
// asi_stream_in_endofpacket      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkAvalonStream2MTL_LCD24bit(csi_clockreset_clk,
				   csi_clockreset_reset_n,

				   asi_stream_in_data,
				   asi_stream_in_valid,
				   asi_stream_in_startofpacket,
				   asi_stream_in_endofpacket,

				   asi_stream_in_ready,

				   coe_tpadlcd_mtl_r,

				   coe_tpadlcd_mtl_g,

				   coe_tpadlcd_mtl_b,

				   coe_tpadlcd_mtl_hsd,

				   coe_tpadlcd_mtl_vsd);
  input  csi_clockreset_clk;
  input  csi_clockreset_reset_n;

  // action method asi_stream_in
  input  [23 : 0] asi_stream_in_data;
  input  asi_stream_in_valid;
  input  asi_stream_in_startofpacket;
  input  asi_stream_in_endofpacket;

  // value method asi_stream_in_ready
  output asi_stream_in_ready;

  // value method coe_tpadlcd_mtl_r
  output [7 : 0] coe_tpadlcd_mtl_r;

  // value method coe_tpadlcd_mtl_g
  output [7 : 0] coe_tpadlcd_mtl_g;

  // value method coe_tpadlcd_mtl_b
  output [7 : 0] coe_tpadlcd_mtl_b;

  // value method coe_tpadlcd_mtl_hsd
  output coe_tpadlcd_mtl_hsd;

  // value method coe_tpadlcd_mtl_vsd
  output coe_tpadlcd_mtl_vsd;

  // signals for module outputs
  wire [7 : 0] coe_tpadlcd_mtl_b, coe_tpadlcd_mtl_g, coe_tpadlcd_mtl_r;
  wire asi_stream_in_ready, coe_tpadlcd_mtl_hsd, coe_tpadlcd_mtl_vsd;

  // inlined wires
  wire [26 : 0] streamIn_d_dw$wget;

  // register lcdtiming_hsd
  reg lcdtiming_hsd;
  wire lcdtiming_hsd$D_IN, lcdtiming_hsd$EN;

  // register lcdtiming_pixel_out
  reg [24 : 0] lcdtiming_pixel_out;
  wire [24 : 0] lcdtiming_pixel_out$D_IN;
  wire lcdtiming_pixel_out$EN;

  // register lcdtiming_vsd
  reg lcdtiming_vsd;
  wire lcdtiming_vsd$D_IN, lcdtiming_vsd$EN;

  // register lcdtiming_x
  reg [11 : 0] lcdtiming_x;
  wire [11 : 0] lcdtiming_x$D_IN;
  wire lcdtiming_x$EN;

  // register lcdtiming_y
  reg [11 : 0] lcdtiming_y;
  wire [11 : 0] lcdtiming_y$D_IN;
  wire lcdtiming_y$EN;

  // ports of submodule lcdtiming_pixel_buf
  wire [24 : 0] lcdtiming_pixel_buf$D_IN, lcdtiming_pixel_buf$D_OUT;
  wire lcdtiming_pixel_buf$CLR,
       lcdtiming_pixel_buf$DEQ,
       lcdtiming_pixel_buf$EMPTY_N,
       lcdtiming_pixel_buf$ENQ,
       lcdtiming_pixel_buf$FULL_N;

  // ports of submodule streamIn_f
  wire [25 : 0] streamIn_f$D_IN, streamIn_f$D_OUT;
  wire streamIn_f$CLR,
       streamIn_f$DEQ,
       streamIn_f$EMPTY_N,
       streamIn_f$ENQ,
       streamIn_f$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_connect_stream_to_lcd_interface,
       CAN_FIRE_RL_lcdtiming_every_clock_cycle,
       CAN_FIRE_RL_streamIn_push_data_into_fifo,
       CAN_FIRE_asi_stream_in,
       WILL_FIRE_RL_connect_stream_to_lcd_interface,
       WILL_FIRE_RL_lcdtiming_every_clock_cycle,
       WILL_FIRE_RL_streamIn_push_data_into_fifo,
       WILL_FIRE_asi_stream_in;

  // remaining internal signals
  wire [7 : 0] IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d34,
	       IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d37,
	       IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d40;
  wire NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59,
       lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65,
       lcdtiming_x_SLT_1009___d66;

  // action method asi_stream_in
  assign CAN_FIRE_asi_stream_in = 1'd1 ;
  assign WILL_FIRE_asi_stream_in = 1'd1 ;

  // value method asi_stream_in_ready
  assign asi_stream_in_ready = streamIn_f$FULL_N ;

  // value method coe_tpadlcd_mtl_r
  assign coe_tpadlcd_mtl_r = lcdtiming_pixel_out[24:17] ;

  // value method coe_tpadlcd_mtl_g
  assign coe_tpadlcd_mtl_g = lcdtiming_pixel_out[16:9] ;

  // value method coe_tpadlcd_mtl_b
  assign coe_tpadlcd_mtl_b = lcdtiming_pixel_out[8:1] ;

  // value method coe_tpadlcd_mtl_hsd
  assign coe_tpadlcd_mtl_hsd = lcdtiming_hsd ;

  // value method coe_tpadlcd_mtl_vsd
  assign coe_tpadlcd_mtl_vsd = lcdtiming_vsd ;

  // submodule lcdtiming_pixel_buf
  FIFO2 #(.width(32'd25),
	  .guarded(32'd1)) lcdtiming_pixel_buf(.RST_N(csi_clockreset_reset_n),
					       .CLK(csi_clockreset_clk),
					       .D_IN(lcdtiming_pixel_buf$D_IN),
					       .ENQ(lcdtiming_pixel_buf$ENQ),
					       .DEQ(lcdtiming_pixel_buf$DEQ),
					       .CLR(lcdtiming_pixel_buf$CLR),
					       .D_OUT(lcdtiming_pixel_buf$D_OUT),
					       .FULL_N(lcdtiming_pixel_buf$FULL_N),
					       .EMPTY_N(lcdtiming_pixel_buf$EMPTY_N));

  // submodule streamIn_f
  FIFOL1 #(.width(32'd26)) streamIn_f(.RST_N(csi_clockreset_reset_n),
				      .CLK(csi_clockreset_clk),
				      .D_IN(streamIn_f$D_IN),
				      .ENQ(streamIn_f$ENQ),
				      .DEQ(streamIn_f$DEQ),
				      .CLR(streamIn_f$CLR),
				      .D_OUT(streamIn_f$D_OUT),
				      .FULL_N(streamIn_f$FULL_N),
				      .EMPTY_N(streamIn_f$EMPTY_N));

  // rule RL_connect_stream_to_lcd_interface
  assign CAN_FIRE_RL_connect_stream_to_lcd_interface =
	     streamIn_f$EMPTY_N && lcdtiming_pixel_buf$FULL_N ;
  assign WILL_FIRE_RL_connect_stream_to_lcd_interface =
	     CAN_FIRE_RL_connect_stream_to_lcd_interface ;

  // rule RL_lcdtiming_every_clock_cycle
  assign CAN_FIRE_RL_lcdtiming_every_clock_cycle = 1'd1 ;
  assign WILL_FIRE_RL_lcdtiming_every_clock_cycle = 1'd1 ;

  // rule RL_streamIn_push_data_into_fifo
  assign CAN_FIRE_RL_streamIn_push_data_into_fifo =
	     streamIn_f$FULL_N && asi_stream_in_valid &&
	     streamIn_d_dw$wget[26] ;
  assign WILL_FIRE_RL_streamIn_push_data_into_fifo =
	     CAN_FIRE_RL_streamIn_push_data_into_fifo ;

  // inlined wires
  assign streamIn_d_dw$wget =
	     { 1'd1,
	       asi_stream_in_data,
	       asi_stream_in_startofpacket,
	       asi_stream_in_endofpacket } ;

  // register lcdtiming_hsd
  assign lcdtiming_hsd$D_IN = (lcdtiming_x ^ 12'h800) >= 12'd2032 ;
  assign lcdtiming_hsd$EN = 1'd1 ;

  // register lcdtiming_pixel_out
  assign lcdtiming_pixel_out$D_IN =
	     { IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d34,
	       IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d37,
	       IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d40,
	       NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 } ;
  assign lcdtiming_pixel_out$EN = 1'd1 ;

  // register lcdtiming_vsd
  assign lcdtiming_vsd$D_IN = (lcdtiming_y ^ 12'h800) >= 12'd2038 ;
  assign lcdtiming_vsd$EN = 1'd1 ;

  // register lcdtiming_x
  assign lcdtiming_x$D_IN =
	     lcdtiming_x_SLT_1009___d66 ? lcdtiming_x + 12'd1 : 12'd4050 ;
  assign lcdtiming_x$EN = 1'd1 ;

  // register lcdtiming_y
  assign lcdtiming_y$D_IN =
	     ((lcdtiming_y ^ 12'h800) < 12'd2549) ?
	       lcdtiming_y + 12'd1 :
	       12'd4073 ;
  assign lcdtiming_y$EN = !lcdtiming_x_SLT_1009___d66 ;

  // submodule lcdtiming_pixel_buf
  assign lcdtiming_pixel_buf$D_IN = streamIn_f$D_OUT[25:1] ;
  assign lcdtiming_pixel_buf$ENQ =
	     CAN_FIRE_RL_connect_stream_to_lcd_interface ;
  assign lcdtiming_pixel_buf$DEQ =
	     NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 &&
	     lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65 ;
  assign lcdtiming_pixel_buf$CLR = 1'b0 ;

  // submodule streamIn_f
  assign streamIn_f$D_IN = streamIn_d_dw$wget[25:0] ;
  assign streamIn_f$ENQ = CAN_FIRE_RL_streamIn_push_data_into_fifo ;
  assign streamIn_f$DEQ = CAN_FIRE_RL_connect_stream_to_lcd_interface ;
  assign streamIn_f$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d34 =
	     NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 ?
	       (lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65 ?
		  lcdtiming_pixel_buf$D_OUT[24:17] :
		  8'd255) :
	       8'd0 ;
  assign IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d37 =
	     NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 ?
	       (lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65 ?
		  lcdtiming_pixel_buf$D_OUT[16:9] :
		  8'd0) :
	       8'd0 ;
  assign IF_NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y__ETC___d40 =
	     NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 ?
	       (lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65 ?
		  lcdtiming_pixel_buf$D_OUT[8:1] :
		  8'd0) :
	       8'd0 ;
  assign NOT_lcdtiming_y_BIT_11_4_5_AND_lcdtiming_y_SLT_ETC___d59 =
	     !lcdtiming_y[11] && (lcdtiming_y ^ 12'h800) < 12'd2528 &&
	     !lcdtiming_x[11] &&
	     (lcdtiming_x ^ 12'h800) < 12'd2848 ;
  assign lcdtiming_pixel_buf_i_notEmpty__3_AND_lcdtimin_ETC___d65 =
	     lcdtiming_pixel_buf$EMPTY_N &&
	     lcdtiming_pixel_buf$D_OUT[0] ==
	     (lcdtiming_x == 12'd0 && lcdtiming_y == 12'd0) ;
  assign lcdtiming_x_SLT_1009___d66 = (lcdtiming_x ^ 12'h800) < 12'd3057 ;

  // handling of inlined registers

  always@(posedge csi_clockreset_clk)
  begin
    if (!csi_clockreset_reset_n)
      begin
        lcdtiming_x <= `BSV_ASSIGNMENT_DELAY 12'd4050;
	lcdtiming_y <= `BSV_ASSIGNMENT_DELAY 12'd4073;
      end
    else
      begin
        if (lcdtiming_x$EN)
	  lcdtiming_x <= `BSV_ASSIGNMENT_DELAY lcdtiming_x$D_IN;
	if (lcdtiming_y$EN)
	  lcdtiming_y <= `BSV_ASSIGNMENT_DELAY lcdtiming_y$D_IN;
      end
    if (lcdtiming_hsd$EN)
      lcdtiming_hsd <= `BSV_ASSIGNMENT_DELAY lcdtiming_hsd$D_IN;
    if (lcdtiming_pixel_out$EN)
      lcdtiming_pixel_out <= `BSV_ASSIGNMENT_DELAY lcdtiming_pixel_out$D_IN;
    if (lcdtiming_vsd$EN)
      lcdtiming_vsd <= `BSV_ASSIGNMENT_DELAY lcdtiming_vsd$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    lcdtiming_hsd = 1'h0;
    lcdtiming_pixel_out = 25'h0AAAAAA;
    lcdtiming_vsd = 1'h0;
    lcdtiming_x = 12'hAAA;
    lcdtiming_y = 12'hAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAvalonStream2MTL_LCD24bit

