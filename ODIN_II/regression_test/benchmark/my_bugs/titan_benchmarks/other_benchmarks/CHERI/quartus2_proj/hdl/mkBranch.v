//
// Generated by Bluespec Compiler, version 2012.07.beta1 (build 29243, 2012-07-26)
//
// On Fri Aug 31 13:44:20 BST 2012
//
// Method conflict info:
// Method: getPc
// Conflict-free: putRegisterTarget, getEpoch
// Sequenced before: putTarget, pcWriteback
// Conflicts: getPc
//
// Method: putTarget
// Conflict-free: pcWriteback, getEpoch
// Sequenced after: getPc
// Sequenced after (restricted): putRegisterTarget
// Conflicts: putTarget
//
// Method: putRegisterTarget
// Conflict-free: getPc, pcWriteback, getEpoch
// Sequenced before (restricted): putTarget
// Conflicts: putRegisterTarget
//
// Method: pcWriteback
// Conflict-free: putTarget, putRegisterTarget
// Sequenced after: getPc, getEpoch
// Conflicts: pcWriteback
//
// Method: getEpoch
// Conflict-free: getPc, putTarget, putRegisterTarget, getEpoch
// Sequenced before: pcWriteback
//
//
// Ports:
// Name                         I/O  size props
// getPc                          O    67
// RDY_getPc                      O     1
// RDY_putTarget                  O     1
// RDY_putRegisterTarget          O     1
// RDY_pcWriteback                O     1
// getEpoch                       O     3 reg
// RDY_getEpoch                   O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// getPc_id                       I     4 unused
// getPc_fromDebug                I     1
// putTarget_branchType           I     2
// putTarget_target               I    64
// putTarget_instEpoch            I     3
// putTarget_id                   I     4
// putTarget_fromDebug            I     1
// putRegisterTarget_target       I    64
// putRegisterTarget_instEpoch    I     3
// putRegisterTarget_id           I     4
// putRegisterTarget_fromDebug    I     1
// pcWriteback_truePc             I    65
// pcWriteback_exception          I     1
// pcWriteback_fromDebug          I     1
// EN_putTarget                   I     1
// EN_putRegisterTarget           I     1
// EN_pcWriteback                 I     1
// EN_getPc                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkBranch(CLK,
		RST_N,

		getPc_id,
		getPc_fromDebug,
		EN_getPc,
		getPc,
		RDY_getPc,

		putTarget_branchType,
		putTarget_target,
		putTarget_instEpoch,
		putTarget_id,
		putTarget_fromDebug,
		EN_putTarget,
		RDY_putTarget,

		putRegisterTarget_target,
		putRegisterTarget_instEpoch,
		putRegisterTarget_id,
		putRegisterTarget_fromDebug,
		EN_putRegisterTarget,
		RDY_putRegisterTarget,

		pcWriteback_truePc,
		pcWriteback_exception,
		pcWriteback_fromDebug,
		EN_pcWriteback,
		RDY_pcWriteback,

		getEpoch,
		RDY_getEpoch);
  input  CLK;
  input  RST_N;

  // actionvalue method getPc
  input  [3 : 0] getPc_id;
  input  getPc_fromDebug;
  input  EN_getPc;
  output [66 : 0] getPc;
  output RDY_getPc;

  // action method putTarget
  input  [1 : 0] putTarget_branchType;
  input  [63 : 0] putTarget_target;
  input  [2 : 0] putTarget_instEpoch;
  input  [3 : 0] putTarget_id;
  input  putTarget_fromDebug;
  input  EN_putTarget;
  output RDY_putTarget;

  // action method putRegisterTarget
  input  [63 : 0] putRegisterTarget_target;
  input  [2 : 0] putRegisterTarget_instEpoch;
  input  [3 : 0] putRegisterTarget_id;
  input  putRegisterTarget_fromDebug;
  input  EN_putRegisterTarget;
  output RDY_putRegisterTarget;

  // action method pcWriteback
  input  [64 : 0] pcWriteback_truePc;
  input  pcWriteback_exception;
  input  pcWriteback_fromDebug;
  input  EN_pcWriteback;
  output RDY_pcWriteback;

  // value method getEpoch
  output [2 : 0] getEpoch;
  output RDY_getEpoch;

  // signals for module outputs
  wire [66 : 0] getPc;
  wire [2 : 0] getEpoch;
  wire RDY_getEpoch,
       RDY_getPc,
       RDY_pcWriteback,
       RDY_putRegisterTarget,
       RDY_putTarget;

  // inlined wires
  wire [71 : 0] registerTarget_rw_enq$wget;
  wire [1 : 0] branchHistory_serverAdapterA_outData_outData$wget;
  wire branchHistory_serverAdapterA_outData_enqData$whas,
       branchHistory_serverAdapterA_outData_outData$whas,
       branchHistory_serverAdapterB_outData_enqData$whas,
       branchHistory_serverAdapterB_writeWithResp$whas,
       jumpTargets_serverAdapterA_outData_enqData$whas,
       jumpTargets_serverAdapterA_outData_outData$whas,
       jumpTargets_serverAdapterB_outData_enqData$whas,
       jumpTargets_serverAdapterB_writeWithResp$whas,
       registerTarget_rw_enq$whas;

  // register branchHist
  reg [5 : 0] branchHist;
  wire [5 : 0] branchHist$D_IN;
  wire branchHist$EN;

  // register branchHistory_serverAdapterA_cnt
  reg [2 : 0] branchHistory_serverAdapterA_cnt;
  wire [2 : 0] branchHistory_serverAdapterA_cnt$D_IN;
  wire branchHistory_serverAdapterA_cnt$EN;

  // register branchHistory_serverAdapterA_s1
  reg [1 : 0] branchHistory_serverAdapterA_s1;
  wire [1 : 0] branchHistory_serverAdapterA_s1$D_IN;
  wire branchHistory_serverAdapterA_s1$EN;

  // register branchHistory_serverAdapterB_cnt
  reg [2 : 0] branchHistory_serverAdapterB_cnt;
  wire [2 : 0] branchHistory_serverAdapterB_cnt$D_IN;
  wire branchHistory_serverAdapterB_cnt$EN;

  // register branchHistory_serverAdapterB_s1
  reg [1 : 0] branchHistory_serverAdapterB_s1;
  wire [1 : 0] branchHistory_serverAdapterB_s1$D_IN;
  wire branchHistory_serverAdapterB_s1$EN;

  // register countIn
  reg [4 : 0] countIn;
  wire [4 : 0] countIn$D_IN;
  wire countIn$EN;

  // register countOut
  reg [4 : 0] countOut;
  wire [4 : 0] countOut$D_IN;
  wire countOut$EN;

  // register epoch
  reg [2 : 0] epoch;
  wire [2 : 0] epoch$D_IN;
  wire epoch$EN;

  // register flushCount
  reg [3 : 0] flushCount;
  wire [3 : 0] flushCount$D_IN;
  wire flushCount$EN;

  // register issueEpoch
  reg [2 : 0] issueEpoch;
  wire [2 : 0] issueEpoch$D_IN;
  wire issueEpoch$EN;

  // register jumpTargets_serverAdapterA_cnt
  reg [2 : 0] jumpTargets_serverAdapterA_cnt;
  wire [2 : 0] jumpTargets_serverAdapterA_cnt$D_IN;
  wire jumpTargets_serverAdapterA_cnt$EN;

  // register jumpTargets_serverAdapterA_s1
  reg [1 : 0] jumpTargets_serverAdapterA_s1;
  wire [1 : 0] jumpTargets_serverAdapterA_s1$D_IN;
  wire jumpTargets_serverAdapterA_s1$EN;

  // register jumpTargets_serverAdapterB_cnt
  reg [2 : 0] jumpTargets_serverAdapterB_cnt;
  wire [2 : 0] jumpTargets_serverAdapterB_cnt$D_IN;
  wire jumpTargets_serverAdapterB_cnt$EN;

  // register jumpTargets_serverAdapterB_s1
  reg [1 : 0] jumpTargets_serverAdapterB_s1;
  wire [1 : 0] jumpTargets_serverAdapterB_s1$D_IN;
  wire jumpTargets_serverAdapterB_s1$EN;

  // register pc
  reg [63 : 0] pc;
  wire [63 : 0] pc$D_IN;
  wire pc$EN;

  // register registerTarget_taggedReg
  reg [72 : 0] registerTarget_taggedReg;
  wire [72 : 0] registerTarget_taggedReg$D_IN;
  wire registerTarget_taggedReg$EN;

  // register specPc
  reg [63 : 0] specPc;
  wire [63 : 0] specPc$D_IN;
  wire specPc$EN;

  // register state
  reg state;
  wire state$D_IN, state$EN;

  // register waitRegTarget
  reg waitRegTarget;
  wire waitRegTarget$D_IN, waitRegTarget$EN;

  // register waitRegTargetHist
  reg [1 : 0] waitRegTargetHist;
  wire [1 : 0] waitRegTargetHist$D_IN;
  wire waitRegTargetHist$EN;

  // ports of submodule branchHistory_memory
  wire [11 : 0] branchHistory_memory$ADDRA, branchHistory_memory$ADDRB;
  wire [1 : 0] branchHistory_memory$DIA,
	       branchHistory_memory$DIB,
	       branchHistory_memory$DOA,
	       branchHistory_memory$DOB;
  wire branchHistory_memory$ENA,
       branchHistory_memory$ENB,
       branchHistory_memory$WEA,
       branchHistory_memory$WEB;

  // ports of submodule branchHistory_serverAdapterA_outDataCore
  wire [1 : 0] branchHistory_serverAdapterA_outDataCore$D_IN,
	       branchHistory_serverAdapterA_outDataCore$D_OUT;
  wire branchHistory_serverAdapterA_outDataCore$CLR,
       branchHistory_serverAdapterA_outDataCore$DEQ,
       branchHistory_serverAdapterA_outDataCore$EMPTY_N,
       branchHistory_serverAdapterA_outDataCore$ENQ,
       branchHistory_serverAdapterA_outDataCore$FULL_N;

  // ports of submodule branchHistory_serverAdapterB_outDataCore
  wire [1 : 0] branchHistory_serverAdapterB_outDataCore$D_IN;
  wire branchHistory_serverAdapterB_outDataCore$CLR,
       branchHistory_serverAdapterB_outDataCore$DEQ,
       branchHistory_serverAdapterB_outDataCore$ENQ,
       branchHistory_serverAdapterB_outDataCore$FULL_N;

  // ports of submodule flushFifo
  wire flushFifo$CLR,
       flushFifo$DEQ,
       flushFifo$D_IN,
       flushFifo$EMPTY_N,
       flushFifo$ENQ;

  // ports of submodule jumpTargets_memory
  wire [31 : 0] jumpTargets_memory$DIA,
		jumpTargets_memory$DIB,
		jumpTargets_memory$DOA,
		jumpTargets_memory$DOB;
  wire [7 : 0] jumpTargets_memory$ADDRA, jumpTargets_memory$ADDRB;
  wire jumpTargets_memory$ENA,
       jumpTargets_memory$ENB,
       jumpTargets_memory$WEA,
       jumpTargets_memory$WEB;

  // ports of submodule jumpTargets_serverAdapterA_outDataCore
  wire [31 : 0] jumpTargets_serverAdapterA_outDataCore$D_IN,
		jumpTargets_serverAdapterA_outDataCore$D_OUT;
  wire jumpTargets_serverAdapterA_outDataCore$CLR,
       jumpTargets_serverAdapterA_outDataCore$DEQ,
       jumpTargets_serverAdapterA_outDataCore$EMPTY_N,
       jumpTargets_serverAdapterA_outDataCore$ENQ,
       jumpTargets_serverAdapterA_outDataCore$FULL_N;

  // ports of submodule jumpTargets_serverAdapterB_outDataCore
  wire [31 : 0] jumpTargets_serverAdapterB_outDataCore$D_IN;
  wire jumpTargets_serverAdapterB_outDataCore$CLR,
       jumpTargets_serverAdapterB_outDataCore$DEQ,
       jumpTargets_serverAdapterB_outDataCore$ENQ,
       jumpTargets_serverAdapterB_outDataCore$FULL_N;

  // ports of submodule keys
  wire [21 : 0] keys$D_IN, keys$D_OUT;
  wire keys$CLR, keys$DEQ, keys$EMPTY_N, keys$ENQ, keys$FULL_N;

  // ports of submodule newEpoch
  wire [2 : 0] newEpoch$D_IN, newEpoch$D_OUT;
  wire newEpoch$CLR, newEpoch$DEQ, newEpoch$EMPTY_N, newEpoch$ENQ;

  // ports of submodule predictionCheck
  wire [89 : 0] predictionCheck$D_IN, predictionCheck$D_OUT;
  wire predictionCheck$CLR,
       predictionCheck$DEQ,
       predictionCheck$EMPTY_N,
       predictionCheck$ENQ,
       predictionCheck$FULL_N;

  // ports of submodule predictions
  reg [71 : 0] predictions$D_IN;
  wire [71 : 0] predictions$D_OUT;
  wire predictions$CLR,
       predictions$DEQ,
       predictions$EMPTY_N,
       predictions$ENQ,
       predictions$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_branchHistory_serverAdapterA_outData_enqAndDeq,
       WILL_FIRE_RL_branchHistory_serverAdapterA_outData_setFirstEnq,
       WILL_FIRE_RL_dumpRegisterTarget,
       WILL_FIRE_RL_flushDelay,
       WILL_FIRE_RL_jumpTargets_serverAdapterA_outData_enqAndDeq,
       WILL_FIRE_RL_primeFifoRule,
       WILL_FIRE_RL_registerTarget_rule_enq,
       WILL_FIRE_RL_reportRegisterTarget;

  // inputs to muxes for submodule ports
  wire [89 : 0] MUX_predictionCheck$enq_1__VAL_1,
		MUX_predictionCheck$enq_1__VAL_2;
  wire [72 : 0] MUX_registerTarget_taggedReg$write_1__VAL_1;
  wire [71 : 0] MUX_predictions$enq_1__VAL_1,
		MUX_predictions$enq_1__VAL_2,
		MUX_predictions$enq_1__VAL_3;
  wire [3 : 0] MUX_flushCount$write_1__VAL_1, MUX_flushCount$write_1__VAL_2;
  wire MUX_predictionCheck$enq_1__SEL_1,
       MUX_predictions$enq_1__SEL_1,
       MUX_registerTarget_taggedReg$write_1__SEL_2,
       MUX_waitRegTarget$write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] IF_putTarget_branchType_EQ_1_24_OR_putTarget_b_ETC___d547;
  wire [63 : 0] IF_registerTarget_rw_enq_whas_THEN_registerTar_ETC___d431,
		_theResult_____2__h8248,
		nextPc___1__h8384,
		pcWriteback_truePc_BITS_63_TO_0__q4,
		x__h8310;
  wire [31 : 0] v__h9023;
  wire [2 : 0] IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q2,
	       IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q3,
	       IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d465,
	       IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d466,
	       SEXT_predictionCheck_first__77_BITS_25_TO_24_97___d463,
	       SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d462,
	       SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d464,
	       branchHistory_serverAdapterA_cnt_8_PLUS_IF_bra_ETC___d44,
	       jumpTargets_serverAdapterA_cnt_52_PLUS_IF_jump_ETC___d158;
  wire [1 : 0] predictionCheckD_OUT_BITS_25_TO_24__q1;
  wire IF_predictionCheck_first__77_BITS_23_TO_22_78__ETC___d508,
       IF_putTarget_branchType_EQ_1_24_THEN_branchHis_ETC___d546,
       branchHistory_serverAdapterA_outData_outData_w_ETC___d367,
       predictionCheck_first__77_BITS_89_TO_26_89_EQ__ETC___d495,
       registerTarget_taggedReg_48_BIT_72_49_OR_regis_ETC___d256;

  // actionvalue method getPc
  assign getPc = { _theResult_____2__h8248, issueEpoch } ;
  assign RDY_getPc =
	     !flushFifo$EMPTY_N && predictions$EMPTY_N &&
	     (branchHistory_serverAdapterA_cnt ^ 3'h4) < 3'd7 &&
	     (jumpTargets_serverAdapterA_cnt ^ 3'h4) < 3'd7 &&
	     keys$FULL_N ;

  // action method putTarget
  assign RDY_putTarget =
	     state && !waitRegTarget &&
	     (branchHistory_serverAdapterA_outDataCore$EMPTY_N ||
	      branchHistory_serverAdapterA_outData_enqData$whas) &&
	     branchHistory_serverAdapterA_outData_outData_w_ETC___d367 ;

  // action method putRegisterTarget
  assign RDY_putRegisterTarget = state && !registerTarget_taggedReg[72] ;

  // action method pcWriteback
  assign RDY_pcWriteback =
	     predictionCheck$EMPTY_N &&
	     (jumpTargets_serverAdapterB_cnt ^ 3'h4) < 3'd7 &&
	     (branchHistory_serverAdapterB_cnt ^ 3'h4) < 3'd7 ;

  // value method getEpoch
  assign getEpoch = epoch ;
  assign RDY_getEpoch = 1'd1 ;

  // submodule branchHistory_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd12),
	  .DATA_WIDTH(32'd2),
	  .MEMSIZE(13'd4096)) branchHistory_memory(.CLKA(CLK),
						   .CLKB(CLK),
						   .ADDRA(branchHistory_memory$ADDRA),
						   .ADDRB(branchHistory_memory$ADDRB),
						   .DIA(branchHistory_memory$DIA),
						   .DIB(branchHistory_memory$DIB),
						   .WEA(branchHistory_memory$WEA),
						   .WEB(branchHistory_memory$WEB),
						   .ENA(branchHistory_memory$ENA),
						   .ENB(branchHistory_memory$ENB),
						   .DOA(branchHistory_memory$DOA),
						   .DOB(branchHistory_memory$DOB));

  // submodule branchHistory_serverAdapterA_outDataCore
  SizedFIFO #(.p1width(32'd2),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) branchHistory_serverAdapterA_outDataCore(.RST_N(RST_N),
									.CLK(CLK),
									.D_IN(branchHistory_serverAdapterA_outDataCore$D_IN),
									.ENQ(branchHistory_serverAdapterA_outDataCore$ENQ),
									.DEQ(branchHistory_serverAdapterA_outDataCore$DEQ),
									.CLR(branchHistory_serverAdapterA_outDataCore$CLR),
									.D_OUT(branchHistory_serverAdapterA_outDataCore$D_OUT),
									.FULL_N(branchHistory_serverAdapterA_outDataCore$FULL_N),
									.EMPTY_N(branchHistory_serverAdapterA_outDataCore$EMPTY_N));

  // submodule branchHistory_serverAdapterB_outDataCore
  SizedFIFO #(.p1width(32'd2),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) branchHistory_serverAdapterB_outDataCore(.RST_N(RST_N),
									.CLK(CLK),
									.D_IN(branchHistory_serverAdapterB_outDataCore$D_IN),
									.ENQ(branchHistory_serverAdapterB_outDataCore$ENQ),
									.DEQ(branchHistory_serverAdapterB_outDataCore$DEQ),
									.CLR(branchHistory_serverAdapterB_outDataCore$CLR),
									.D_OUT(),
									.FULL_N(branchHistory_serverAdapterB_outDataCore$FULL_N),
									.EMPTY_N());

  // submodule flushFifo
  FIFO1 #(.width(32'd1), .guarded(32'd0)) flushFifo(.RST_N(RST_N),
						    .CLK(CLK),
						    .D_IN(flushFifo$D_IN),
						    .ENQ(flushFifo$ENQ),
						    .DEQ(flushFifo$DEQ),
						    .CLR(flushFifo$CLR),
						    .D_OUT(),
						    .FULL_N(),
						    .EMPTY_N(flushFifo$EMPTY_N));

  // submodule jumpTargets_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd8),
	  .DATA_WIDTH(32'd32),
	  .MEMSIZE(9'd256)) jumpTargets_memory(.CLKA(CLK),
					       .CLKB(CLK),
					       .ADDRA(jumpTargets_memory$ADDRA),
					       .ADDRB(jumpTargets_memory$ADDRB),
					       .DIA(jumpTargets_memory$DIA),
					       .DIB(jumpTargets_memory$DIB),
					       .WEA(jumpTargets_memory$WEA),
					       .WEB(jumpTargets_memory$WEB),
					       .ENA(jumpTargets_memory$ENA),
					       .ENB(jumpTargets_memory$ENB),
					       .DOA(jumpTargets_memory$DOA),
					       .DOB(jumpTargets_memory$DOB));

  // submodule jumpTargets_serverAdapterA_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) jumpTargets_serverAdapterA_outDataCore(.RST_N(RST_N),
								      .CLK(CLK),
								      .D_IN(jumpTargets_serverAdapterA_outDataCore$D_IN),
								      .ENQ(jumpTargets_serverAdapterA_outDataCore$ENQ),
								      .DEQ(jumpTargets_serverAdapterA_outDataCore$DEQ),
								      .CLR(jumpTargets_serverAdapterA_outDataCore$CLR),
								      .D_OUT(jumpTargets_serverAdapterA_outDataCore$D_OUT),
								      .FULL_N(jumpTargets_serverAdapterA_outDataCore$FULL_N),
								      .EMPTY_N(jumpTargets_serverAdapterA_outDataCore$EMPTY_N));

  // submodule jumpTargets_serverAdapterB_outDataCore
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) jumpTargets_serverAdapterB_outDataCore(.RST_N(RST_N),
								      .CLK(CLK),
								      .D_IN(jumpTargets_serverAdapterB_outDataCore$D_IN),
								      .ENQ(jumpTargets_serverAdapterB_outDataCore$ENQ),
								      .DEQ(jumpTargets_serverAdapterB_outDataCore$DEQ),
								      .CLR(jumpTargets_serverAdapterB_outDataCore$CLR),
								      .D_OUT(),
								      .FULL_N(jumpTargets_serverAdapterB_outDataCore$FULL_N),
								      .EMPTY_N());

  // submodule keys
  FIFO2 #(.width(32'd22), .guarded(32'd1)) keys(.RST_N(RST_N),
						.CLK(CLK),
						.D_IN(keys$D_IN),
						.ENQ(keys$ENQ),
						.DEQ(keys$DEQ),
						.CLR(keys$CLR),
						.D_OUT(keys$D_OUT),
						.FULL_N(keys$FULL_N),
						.EMPTY_N(keys$EMPTY_N));

  // submodule newEpoch
  FIFO2 #(.width(32'd3), .guarded(32'd0)) newEpoch(.RST_N(RST_N),
						   .CLK(CLK),
						   .D_IN(newEpoch$D_IN),
						   .ENQ(newEpoch$ENQ),
						   .DEQ(newEpoch$DEQ),
						   .CLR(newEpoch$CLR),
						   .D_OUT(newEpoch$D_OUT),
						   .FULL_N(),
						   .EMPTY_N(newEpoch$EMPTY_N));

  // submodule predictionCheck
  SizedFIFO #(.p1width(32'd90),
	      .p2depth(32'd10),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) predictionCheck(.RST_N(RST_N),
					       .CLK(CLK),
					       .D_IN(predictionCheck$D_IN),
					       .ENQ(predictionCheck$ENQ),
					       .DEQ(predictionCheck$DEQ),
					       .CLR(predictionCheck$CLR),
					       .D_OUT(predictionCheck$D_OUT),
					       .FULL_N(predictionCheck$FULL_N),
					       .EMPTY_N(predictionCheck$EMPTY_N));

  // submodule predictions
  SizedFIFO #(.p1width(32'd72),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) predictions(.RST_N(RST_N),
					   .CLK(CLK),
					   .D_IN(predictions$D_IN),
					   .ENQ(predictions$ENQ),
					   .DEQ(predictions$DEQ),
					   .CLR(predictions$CLR),
					   .D_OUT(predictions$D_OUT),
					   .FULL_N(predictions$FULL_N),
					   .EMPTY_N(predictions$EMPTY_N));

  // rule RL_flushDelay
  assign WILL_FIRE_RL_flushDelay = state && flushFifo$EMPTY_N ;

  // rule RL_reportRegisterTarget
  assign WILL_FIRE_RL_reportRegisterTarget =
	     registerTarget_taggedReg_48_BIT_72_49_OR_regis_ETC___d256 &&
	     state &&
	     waitRegTarget ;

  // rule RL_dumpRegisterTarget
  assign WILL_FIRE_RL_dumpRegisterTarget =
	     (registerTarget_taggedReg[72] || registerTarget_rw_enq$whas) &&
	     state &&
	     !waitRegTarget ;

  // rule RL_primeFifoRule
  assign WILL_FIRE_RL_primeFifoRule = predictions$FULL_N && !state ;

  // rule RL_registerTarget_rule_enq
  assign WILL_FIRE_RL_registerTarget_rule_enq =
	     registerTarget_rw_enq$whas &&
	     !MUX_registerTarget_taggedReg$write_1__SEL_2 ;

  // rule RL_branchHistory_serverAdapterA_outData_setFirstEnq
  assign WILL_FIRE_RL_branchHistory_serverAdapterA_outData_setFirstEnq =
	     !branchHistory_serverAdapterA_outDataCore$EMPTY_N &&
	     branchHistory_serverAdapterA_outData_enqData$whas ;

  // rule RL_branchHistory_serverAdapterA_outData_enqAndDeq
  assign WILL_FIRE_RL_branchHistory_serverAdapterA_outData_enqAndDeq =
	     branchHistory_serverAdapterA_outDataCore$EMPTY_N &&
	     branchHistory_serverAdapterA_outDataCore$FULL_N &&
	     EN_putTarget &&
	     branchHistory_serverAdapterA_outData_enqData$whas ;

  // rule RL_jumpTargets_serverAdapterA_outData_enqAndDeq
  assign WILL_FIRE_RL_jumpTargets_serverAdapterA_outData_enqAndDeq =
	     jumpTargets_serverAdapterA_outDataCore$EMPTY_N &&
	     jumpTargets_serverAdapterA_outDataCore$FULL_N &&
	     EN_putTarget &&
	     jumpTargets_serverAdapterA_outData_enqData$whas ;

  // inputs to muxes for submodule ports
  assign MUX_predictionCheck$enq_1__SEL_1 =
	     EN_putTarget &&
	     (putTarget_branchType != 2'd3 ||
	      branchHistory_serverAdapterA_outData_outData$wget[1] ||
	      putTarget_fromDebug) ;
  assign MUX_predictions$enq_1__SEL_1 =
	     EN_putTarget &&
	     (putTarget_branchType != 2'd3 ||
	      branchHistory_serverAdapterA_outData_outData$wget[1]) &&
	     !putTarget_fromDebug ;
  assign MUX_registerTarget_taggedReg$write_1__SEL_2 =
	     WILL_FIRE_RL_dumpRegisterTarget ||
	     WILL_FIRE_RL_reportRegisterTarget ;
  assign MUX_waitRegTarget$write_1__SEL_1 =
	     EN_putTarget && putTarget_branchType == 2'd3 &&
	     IF_putTarget_branchType_EQ_1_24_THEN_branchHis_ETC___d546 &&
	     !putTarget_fromDebug ;
  assign MUX_flushCount$write_1__VAL_1 =
	     (flushCount == 4'd4) ? 4'd0 : flushCount + 4'd1 ;
  assign MUX_flushCount$write_1__VAL_2 = flushCount + 4'd1 ;
  assign MUX_predictionCheck$enq_1__VAL_1 =
	     { IF_putTarget_branchType_EQ_1_24_OR_putTarget_b_ETC___d547,
	       branchHistory_serverAdapterA_outData_outData$wget,
	       putTarget_branchType,
	       keys$D_OUT } ;
  assign MUX_predictionCheck$enq_1__VAL_2 =
	     { IF_registerTarget_rw_enq_whas_THEN_registerTar_ETC___d431,
	       waitRegTargetHist,
	       2'd3,
	       keys$D_OUT } ;
  assign MUX_predictions$enq_1__VAL_1 =
	     { (putTarget_branchType == 2'd1) ?
		 !branchHistory_serverAdapterA_outData_outData$wget[1] :
		 putTarget_branchType == 2'd2 ||
		 putTarget_branchType == 2'd3 &&
		 branchHistory_serverAdapterA_outData_outData$wget[1],
	       IF_putTarget_branchType_EQ_1_24_OR_putTarget_b_ETC___d547,
	       putTarget_instEpoch,
	       putTarget_id } ;
  assign MUX_predictions$enq_1__VAL_2 =
	     { registerTarget_rw_enq$whas ?
		 registerTarget_rw_enq$wget[71] :
		 !registerTarget_taggedReg[72] ||
		 registerTarget_taggedReg[71],
	       IF_registerTarget_rw_enq_whas_THEN_registerTar_ETC___d431,
	       registerTarget_rw_enq$whas ?
		 registerTarget_rw_enq$wget[6:0] :
		 registerTarget_taggedReg[6:0] } ;
  assign MUX_predictions$enq_1__VAL_3 =
	     { 1'd1, (flushCount == 4'd0) ? pc : pc + 64'd4, epoch, 4'hA } ;
  assign MUX_registerTarget_taggedReg$write_1__VAL_1 =
	     { 1'd1, registerTarget_rw_enq$wget } ;

  // inlined wires
  assign registerTarget_rw_enq$wget =
	     { 1'd1,
	       putRegisterTarget_target,
	       putRegisterTarget_instEpoch,
	       putRegisterTarget_id } ;
  assign registerTarget_rw_enq$whas =
	     EN_putRegisterTarget && !putRegisterTarget_fromDebug ;
  assign branchHistory_serverAdapterA_outData_enqData$whas =
	     branchHistory_serverAdapterA_outDataCore$FULL_N &&
	     branchHistory_serverAdapterA_s1[1] &&
	     branchHistory_serverAdapterA_s1[0] ;
  assign branchHistory_serverAdapterA_outData_outData$wget =
	     WILL_FIRE_RL_branchHistory_serverAdapterA_outData_setFirstEnq ?
	       branchHistory_memory$DOA :
	       branchHistory_serverAdapterA_outDataCore$D_OUT ;
  assign branchHistory_serverAdapterA_outData_outData$whas =
	     WILL_FIRE_RL_branchHistory_serverAdapterA_outData_setFirstEnq ||
	     branchHistory_serverAdapterA_outDataCore$EMPTY_N ;
  assign branchHistory_serverAdapterB_outData_enqData$whas =
	     branchHistory_serverAdapterB_outDataCore$FULL_N &&
	     branchHistory_serverAdapterB_s1[1] &&
	     branchHistory_serverAdapterB_s1[0] ;
  assign branchHistory_serverAdapterB_writeWithResp$whas =
	     EN_pcWriteback && pcWriteback_truePc[64] &&
	     !pcWriteback_fromDebug &&
	     (predictionCheck$D_OUT[23:22] == 2'd1 ||
	      predictionCheck$D_OUT[23:22] == 2'd3) ;
  assign jumpTargets_serverAdapterA_outData_enqData$whas =
	     jumpTargets_serverAdapterA_outDataCore$FULL_N &&
	     jumpTargets_serverAdapterA_s1[1] &&
	     jumpTargets_serverAdapterA_s1[0] ;
  assign jumpTargets_serverAdapterA_outData_outData$whas =
	     jumpTargets_serverAdapterA_outDataCore$EMPTY_N ||
	     !jumpTargets_serverAdapterA_outDataCore$EMPTY_N &&
	     jumpTargets_serverAdapterA_outData_enqData$whas ;
  assign jumpTargets_serverAdapterB_outData_enqData$whas =
	     jumpTargets_serverAdapterB_outDataCore$FULL_N &&
	     jumpTargets_serverAdapterB_s1[1] &&
	     jumpTargets_serverAdapterB_s1[0] ;
  assign jumpTargets_serverAdapterB_writeWithResp$whas =
	     EN_pcWriteback && pcWriteback_truePc[64] &&
	     !pcWriteback_fromDebug &&
	     predictionCheck$D_OUT[23:22] == 2'd3 ;

  // register branchHist
  assign branchHist$D_IN =
	     { branchHist[4:0],
	       !branchHistory_serverAdapterA_outData_outData$wget[1] } ;
  assign branchHist$EN = EN_putTarget && putTarget_branchType == 2'd1 ;

  // register branchHistory_serverAdapterA_cnt
  assign branchHistory_serverAdapterA_cnt$D_IN =
	     branchHistory_serverAdapterA_cnt_8_PLUS_IF_bra_ETC___d44 ;
  assign branchHistory_serverAdapterA_cnt$EN = EN_getPc || EN_putTarget ;

  // register branchHistory_serverAdapterA_s1
  assign branchHistory_serverAdapterA_s1$D_IN = { EN_getPc, 1'b1 } ;
  assign branchHistory_serverAdapterA_s1$EN = 1'd1 ;

  // register branchHistory_serverAdapterB_cnt
  assign branchHistory_serverAdapterB_cnt$D_IN =
	     branchHistory_serverAdapterB_cnt + 3'd0 + 3'd0 ;
  assign branchHistory_serverAdapterB_cnt$EN = 1'b0 ;

  // register branchHistory_serverAdapterB_s1
  assign branchHistory_serverAdapterB_s1$D_IN =
	     { branchHistory_serverAdapterB_writeWithResp$whas, 1'b0 } ;
  assign branchHistory_serverAdapterB_s1$EN = 1'd1 ;

  // register countIn
  assign countIn$D_IN = countIn + 5'd1 ;
  assign countIn$EN = EN_getPc ;

  // register countOut
  assign countOut$D_IN = countOut + 5'd1 ;
  assign countOut$EN = EN_pcWriteback ;

  // register epoch
  assign epoch$D_IN =
	     (pcWriteback_truePc[64] && pcWriteback_exception) ?
	       (newEpoch$EMPTY_N ? epoch + 3'd2 : epoch + 3'd1) :
	       newEpoch$D_OUT ;
  assign epoch$EN =
	     EN_pcWriteback &&
	     (pcWriteback_truePc[64] && pcWriteback_exception ||
	      newEpoch$EMPTY_N) ;

  // register flushCount
  assign flushCount$D_IN =
	     WILL_FIRE_RL_flushDelay ?
	       MUX_flushCount$write_1__VAL_1 :
	       MUX_flushCount$write_1__VAL_2 ;
  assign flushCount$EN =
	     WILL_FIRE_RL_flushDelay || WILL_FIRE_RL_primeFifoRule ;

  // register issueEpoch
  assign issueEpoch$D_IN = epoch ;
  assign issueEpoch$EN = EN_getPc ;

  // register jumpTargets_serverAdapterA_cnt
  assign jumpTargets_serverAdapterA_cnt$D_IN =
	     jumpTargets_serverAdapterA_cnt_52_PLUS_IF_jump_ETC___d158 ;
  assign jumpTargets_serverAdapterA_cnt$EN = EN_getPc || EN_putTarget ;

  // register jumpTargets_serverAdapterA_s1
  assign jumpTargets_serverAdapterA_s1$D_IN = { EN_getPc, 1'b1 } ;
  assign jumpTargets_serverAdapterA_s1$EN = 1'd1 ;

  // register jumpTargets_serverAdapterB_cnt
  assign jumpTargets_serverAdapterB_cnt$D_IN =
	     jumpTargets_serverAdapterB_cnt + 3'd0 + 3'd0 ;
  assign jumpTargets_serverAdapterB_cnt$EN = 1'b0 ;

  // register jumpTargets_serverAdapterB_s1
  assign jumpTargets_serverAdapterB_s1$D_IN =
	     { jumpTargets_serverAdapterB_writeWithResp$whas, 1'b0 } ;
  assign jumpTargets_serverAdapterB_s1$EN = 1'd1 ;

  // register pc
  assign pc$D_IN = pcWriteback_truePc[63:0] ;
  assign pc$EN = EN_pcWriteback && pcWriteback_truePc[64] ;

  // register registerTarget_taggedReg
  assign registerTarget_taggedReg$D_IN =
	     WILL_FIRE_RL_registerTarget_rule_enq ?
	       MUX_registerTarget_taggedReg$write_1__VAL_1 :
	       73'h0AAAAAAAAAAAAAAAAAA ;
  assign registerTarget_taggedReg$EN =
	     WILL_FIRE_RL_registerTarget_rule_enq ||
	     WILL_FIRE_RL_dumpRegisterTarget ||
	     WILL_FIRE_RL_reportRegisterTarget ;

  // register specPc
  assign specPc$D_IN = (issueEpoch == epoch) ? x__h8310 : pc ;
  assign specPc$EN = EN_getPc && !getPc_fromDebug ;

  // register state
  assign state$D_IN = 1'd1 ;
  assign state$EN = WILL_FIRE_RL_primeFifoRule && flushCount == 4'd1 ;

  // register waitRegTarget
  assign waitRegTarget$D_IN = MUX_waitRegTarget$write_1__SEL_1 ;
  assign waitRegTarget$EN =
	     EN_putTarget && putTarget_branchType == 2'd3 &&
	     IF_putTarget_branchType_EQ_1_24_THEN_branchHis_ETC___d546 &&
	     !putTarget_fromDebug ||
	     WILL_FIRE_RL_reportRegisterTarget ;

  // register waitRegTargetHist
  assign waitRegTargetHist$D_IN =
	     branchHistory_serverAdapterA_outData_outData$wget ;
  assign waitRegTargetHist$EN = MUX_waitRegTarget$write_1__SEL_1 ;

  // submodule branchHistory_memory
  assign branchHistory_memory$ADDRA = _theResult_____2__h8248[13:2] ;
  assign branchHistory_memory$ADDRB = predictionCheck$D_OUT[11:0] ;
  assign branchHistory_memory$DIA = 2'b10 /* unspecified value */  ;
  assign branchHistory_memory$DIB =
	     IF_predictionCheck_first__77_BITS_23_TO_22_78__ETC___d508 ?
	       (predictionCheck$D_OUT[25] ?
		  IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q2[1:0] :
		  IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q3[1:0]) :
	       (predictionCheck$D_OUT[25] ?
		  IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q3[1:0] :
		  IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q2[1:0]) ;
  assign branchHistory_memory$WEA = 1'd0 ;
  assign branchHistory_memory$WEB = 1'd1 ;
  assign branchHistory_memory$ENA = EN_getPc ;
  assign branchHistory_memory$ENB =
	     branchHistory_serverAdapterB_writeWithResp$whas ;

  // submodule branchHistory_serverAdapterA_outDataCore
  assign branchHistory_serverAdapterA_outDataCore$D_IN =
	     branchHistory_memory$DOA ;
  assign branchHistory_serverAdapterA_outDataCore$ENQ =
	     WILL_FIRE_RL_branchHistory_serverAdapterA_outData_enqAndDeq ||
	     branchHistory_serverAdapterA_outDataCore$FULL_N &&
	     !EN_putTarget &&
	     branchHistory_serverAdapterA_outData_enqData$whas ;
  assign branchHistory_serverAdapterA_outDataCore$DEQ =
	     WILL_FIRE_RL_branchHistory_serverAdapterA_outData_enqAndDeq ||
	     branchHistory_serverAdapterA_outDataCore$EMPTY_N &&
	     EN_putTarget &&
	     !branchHistory_serverAdapterA_outData_enqData$whas ;
  assign branchHistory_serverAdapterA_outDataCore$CLR = 1'b0 ;

  // submodule branchHistory_serverAdapterB_outDataCore
  assign branchHistory_serverAdapterB_outDataCore$D_IN =
	     branchHistory_memory$DOB ;
  assign branchHistory_serverAdapterB_outDataCore$ENQ =
	     branchHistory_serverAdapterB_outDataCore$FULL_N &&
	     branchHistory_serverAdapterB_outData_enqData$whas ;
  assign branchHistory_serverAdapterB_outDataCore$DEQ = 1'b0 ;
  assign branchHistory_serverAdapterB_outDataCore$CLR = 1'b0 ;

  // submodule flushFifo
  assign flushFifo$D_IN = 1'd1 ;
  assign flushFifo$ENQ =
	     EN_pcWriteback && pcWriteback_truePc[64] &&
	     pcWriteback_exception &&
	     !flushFifo$EMPTY_N ;
  assign flushFifo$DEQ = WILL_FIRE_RL_flushDelay && flushCount == 4'd4 ;
  assign flushFifo$CLR = 1'b0 ;

  // submodule jumpTargets_memory
  assign jumpTargets_memory$ADDRA = _theResult_____2__h8248[9:2] ;
  assign jumpTargets_memory$ADDRB = predictionCheck$D_OUT[7:0] ;
  assign jumpTargets_memory$DIA = 32'hAAAAAAAA /* unspecified value */  ;
  assign jumpTargets_memory$DIB = pcWriteback_truePc_BITS_63_TO_0__q4[31:0] ;
  assign jumpTargets_memory$WEA = 1'd0 ;
  assign jumpTargets_memory$WEB = 1'd1 ;
  assign jumpTargets_memory$ENA = EN_getPc ;
  assign jumpTargets_memory$ENB =
	     jumpTargets_serverAdapterB_writeWithResp$whas ;

  // submodule jumpTargets_serverAdapterA_outDataCore
  assign jumpTargets_serverAdapterA_outDataCore$D_IN =
	     jumpTargets_memory$DOA ;
  assign jumpTargets_serverAdapterA_outDataCore$ENQ =
	     WILL_FIRE_RL_jumpTargets_serverAdapterA_outData_enqAndDeq ||
	     jumpTargets_serverAdapterA_outDataCore$FULL_N && !EN_putTarget &&
	     jumpTargets_serverAdapterA_outData_enqData$whas ;
  assign jumpTargets_serverAdapterA_outDataCore$DEQ =
	     WILL_FIRE_RL_jumpTargets_serverAdapterA_outData_enqAndDeq ||
	     jumpTargets_serverAdapterA_outDataCore$EMPTY_N && EN_putTarget &&
	     !jumpTargets_serverAdapterA_outData_enqData$whas ;
  assign jumpTargets_serverAdapterA_outDataCore$CLR = 1'b0 ;

  // submodule jumpTargets_serverAdapterB_outDataCore
  assign jumpTargets_serverAdapterB_outDataCore$D_IN =
	     jumpTargets_memory$DOB ;
  assign jumpTargets_serverAdapterB_outDataCore$ENQ =
	     jumpTargets_serverAdapterB_outDataCore$FULL_N &&
	     jumpTargets_serverAdapterB_outData_enqData$whas ;
  assign jumpTargets_serverAdapterB_outDataCore$DEQ = 1'b0 ;
  assign jumpTargets_serverAdapterB_outDataCore$CLR = 1'b0 ;

  // submodule keys
  assign keys$D_IN = { branchHist, _theResult_____2__h8248[17:2] } ;
  assign keys$ENQ = EN_getPc ;
  assign keys$DEQ =
	     EN_putTarget &&
	     (putTarget_branchType != 2'd3 ||
	      branchHistory_serverAdapterA_outData_outData$wget[1] ||
	      putTarget_fromDebug) ||
	     WILL_FIRE_RL_reportRegisterTarget ;
  assign keys$CLR = 1'b0 ;

  // submodule newEpoch
  assign newEpoch$D_IN = epoch + 3'd1 ;
  assign newEpoch$ENQ =
	     EN_pcWriteback && pcWriteback_truePc[64] &&
	     !pcWriteback_fromDebug &&
	     IF_predictionCheck_first__77_BITS_23_TO_22_78__ETC___d508 &&
	     !pcWriteback_exception ;
  assign newEpoch$DEQ = EN_pcWriteback && newEpoch$EMPTY_N ;
  assign newEpoch$CLR = 1'b0 ;

  // submodule predictionCheck
  assign predictionCheck$D_IN =
	     MUX_predictionCheck$enq_1__SEL_1 ?
	       MUX_predictionCheck$enq_1__VAL_1 :
	       MUX_predictionCheck$enq_1__VAL_2 ;
  assign predictionCheck$ENQ =
	     EN_putTarget &&
	     (putTarget_branchType != 2'd3 ||
	      branchHistory_serverAdapterA_outData_outData$wget[1] ||
	      putTarget_fromDebug) ||
	     WILL_FIRE_RL_reportRegisterTarget ;
  assign predictionCheck$DEQ = EN_pcWriteback ;
  assign predictionCheck$CLR = 1'b0 ;

  // submodule predictions
  always@(MUX_predictions$enq_1__SEL_1 or
	  MUX_predictions$enq_1__VAL_1 or
	  WILL_FIRE_RL_reportRegisterTarget or
	  MUX_predictions$enq_1__VAL_2 or
	  WILL_FIRE_RL_primeFifoRule or MUX_predictions$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_predictions$enq_1__SEL_1:
	  predictions$D_IN = MUX_predictions$enq_1__VAL_1;
      WILL_FIRE_RL_reportRegisterTarget:
	  predictions$D_IN = MUX_predictions$enq_1__VAL_2;
      WILL_FIRE_RL_primeFifoRule:
	  predictions$D_IN = MUX_predictions$enq_1__VAL_3;
      default: predictions$D_IN =
		   72'hAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign predictions$ENQ =
	     EN_putTarget &&
	     (putTarget_branchType != 2'd3 ||
	      branchHistory_serverAdapterA_outData_outData$wget[1]) &&
	     !putTarget_fromDebug ||
	     WILL_FIRE_RL_reportRegisterTarget ||
	     WILL_FIRE_RL_primeFifoRule ;
  assign predictions$DEQ = EN_getPc && !getPc_fromDebug ;
  assign predictions$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q2 =
	     ((IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d466 ^
	       3'h4) <
	      3'd2) ?
	       3'd6 :
	       IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d466 ;
  assign IF_IF_SEXT_predictionCheck_first__77_BITS_25_T_ETC__q3 =
	     ((IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d465 ^
	       3'h4) <
	      3'd2) ?
	       3'd6 :
	       IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d465 ;
  assign IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d465 =
	     ((SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d464 ^
	       3'h4) <=
	      3'd5) ?
	       SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d464 :
	       3'd1 ;
  assign IF_SEXT_predictionCheck_first__77_BITS_25_TO_2_ETC___d466 =
	     ((SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d462 ^
	       3'h4) <=
	      3'd5) ?
	       SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d462 :
	       3'd1 ;
  assign IF_predictionCheck_first__77_BITS_23_TO_22_78__ETC___d508 =
	     (predictionCheck$D_OUT[23:22] == 2'd1) ?
	       !(predictionCheck_first__77_BITS_89_TO_26_89_EQ__ETC___d495 ^
		 predictionCheck$D_OUT[25]) :
	       predictionCheck$D_OUT[23:22] == 2'd3 &&
	       !predictionCheck_first__77_BITS_89_TO_26_89_EQ__ETC___d495 ;
  assign IF_putTarget_branchType_EQ_1_24_THEN_branchHis_ETC___d546 =
	     (putTarget_branchType == 2'd1) ?
	       branchHistory_serverAdapterA_outData_outData$wget[1] :
	       putTarget_branchType != 2'd2 &&
	       (putTarget_branchType != 2'd3 ||
		!branchHistory_serverAdapterA_outData_outData$wget[1]) ;
  assign IF_registerTarget_rw_enq_whas_THEN_registerTar_ETC___d431 =
	     registerTarget_rw_enq$whas ?
	       registerTarget_rw_enq$wget[70:7] :
	       registerTarget_taggedReg[70:7] ;
  assign SEXT_predictionCheck_first__77_BITS_25_TO_24_97___d463 =
	     { predictionCheckD_OUT_BITS_25_TO_24__q1[1],
	       predictionCheckD_OUT_BITS_25_TO_24__q1 } ;
  assign SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d462 =
	     SEXT_predictionCheck_first__77_BITS_25_TO_24_97___d463 + 3'd1 ;
  assign SEXT_predictionCheck_first__77_BITS_25_TO_24_9_ETC___d464 =
	     SEXT_predictionCheck_first__77_BITS_25_TO_24_97___d463 + 3'd7 ;
  assign _theResult_____2__h8248 =
	     (issueEpoch == predictions$D_OUT[6:4] && predictions$D_OUT[71]) ?
	       nextPc___1__h8384 :
	       specPc ;
  assign branchHistory_serverAdapterA_cnt_8_PLUS_IF_bra_ETC___d44 =
	     branchHistory_serverAdapterA_cnt + (EN_getPc ? 3'd1 : 3'd0) +
	     (EN_putTarget ? 3'd7 : 3'd0) ;
  assign branchHistory_serverAdapterA_outData_outData_w_ETC___d367 =
	     branchHistory_serverAdapterA_outData_outData$whas &&
	     (jumpTargets_serverAdapterA_outDataCore$EMPTY_N ||
	      jumpTargets_serverAdapterA_outData_enqData$whas) &&
	     predictionCheck$FULL_N &&
	     keys$EMPTY_N &&
	     predictions$FULL_N &&
	     jumpTargets_serverAdapterA_outData_outData$whas ;
  assign jumpTargets_serverAdapterA_cnt_52_PLUS_IF_jump_ETC___d158 =
	     jumpTargets_serverAdapterA_cnt + (EN_getPc ? 3'd1 : 3'd0) +
	     (EN_putTarget ? 3'd7 : 3'd0) ;
  assign nextPc___1__h8384 =
	     predictions$D_OUT[71] ? predictions$D_OUT[70:7] : specPc ;
  assign pcWriteback_truePc_BITS_63_TO_0__q4 = pcWriteback_truePc[63:0] ;
  assign predictionCheckD_OUT_BITS_25_TO_24__q1 =
	     predictionCheck$D_OUT[25:24] ;
  assign predictionCheck_first__77_BITS_89_TO_26_89_EQ__ETC___d495 =
	     predictionCheck$D_OUT[89:26] == pcWriteback_truePc[63:0] ;
  assign registerTarget_taggedReg_48_BIT_72_49_OR_regis_ETC___d256 =
	     (registerTarget_taggedReg[72] || registerTarget_rw_enq$whas) &&
	     predictions$FULL_N &&
	     predictionCheck$FULL_N &&
	     keys$EMPTY_N ;
  assign v__h9023 =
	     jumpTargets_serverAdapterA_outDataCore$EMPTY_N ?
	       jumpTargets_serverAdapterA_outDataCore$D_OUT :
	       jumpTargets_memory$DOA ;
  assign x__h8310 = _theResult_____2__h8248 + 64'd4 ;
  always@(putTarget_branchType or putTarget_target or v__h9023)
  begin
    case (putTarget_branchType)
      2'd1, 2'd2:
	  IF_putTarget_branchType_EQ_1_24_OR_putTarget_b_ETC___d547 =
	      putTarget_target;
      default: IF_putTarget_branchType_EQ_1_24_OR_putTarget_b_ETC___d547 =
		   { putTarget_target[63:32], v__h9023 };
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        branchHist <= `BSV_ASSIGNMENT_DELAY 6'd0;
	branchHistory_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	branchHistory_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	branchHistory_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	branchHistory_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	countIn <= `BSV_ASSIGNMENT_DELAY 5'd0;
	countOut <= `BSV_ASSIGNMENT_DELAY 5'd0;
	epoch <= `BSV_ASSIGNMENT_DELAY 3'd0;
	flushCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	issueEpoch <= `BSV_ASSIGNMENT_DELAY 3'd0;
	jumpTargets_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	jumpTargets_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	jumpTargets_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	jumpTargets_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	pc <= `BSV_ASSIGNMENT_DELAY 64'h9000000040000000;
	registerTarget_taggedReg <= `BSV_ASSIGNMENT_DELAY
	    73'h0AAAAAAAAAAAAAAAAAA;
	specPc <= `BSV_ASSIGNMENT_DELAY 64'd0;
	state <= `BSV_ASSIGNMENT_DELAY 1'd0;
	waitRegTarget <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (branchHist$EN)
	  branchHist <= `BSV_ASSIGNMENT_DELAY branchHist$D_IN;
	if (branchHistory_serverAdapterA_cnt$EN)
	  branchHistory_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY
	      branchHistory_serverAdapterA_cnt$D_IN;
	if (branchHistory_serverAdapterA_s1$EN)
	  branchHistory_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY
	      branchHistory_serverAdapterA_s1$D_IN;
	if (branchHistory_serverAdapterB_cnt$EN)
	  branchHistory_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY
	      branchHistory_serverAdapterB_cnt$D_IN;
	if (branchHistory_serverAdapterB_s1$EN)
	  branchHistory_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY
	      branchHistory_serverAdapterB_s1$D_IN;
	if (countIn$EN) countIn <= `BSV_ASSIGNMENT_DELAY countIn$D_IN;
	if (countOut$EN) countOut <= `BSV_ASSIGNMENT_DELAY countOut$D_IN;
	if (epoch$EN) epoch <= `BSV_ASSIGNMENT_DELAY epoch$D_IN;
	if (flushCount$EN)
	  flushCount <= `BSV_ASSIGNMENT_DELAY flushCount$D_IN;
	if (issueEpoch$EN)
	  issueEpoch <= `BSV_ASSIGNMENT_DELAY issueEpoch$D_IN;
	if (jumpTargets_serverAdapterA_cnt$EN)
	  jumpTargets_serverAdapterA_cnt <= `BSV_ASSIGNMENT_DELAY
	      jumpTargets_serverAdapterA_cnt$D_IN;
	if (jumpTargets_serverAdapterA_s1$EN)
	  jumpTargets_serverAdapterA_s1 <= `BSV_ASSIGNMENT_DELAY
	      jumpTargets_serverAdapterA_s1$D_IN;
	if (jumpTargets_serverAdapterB_cnt$EN)
	  jumpTargets_serverAdapterB_cnt <= `BSV_ASSIGNMENT_DELAY
	      jumpTargets_serverAdapterB_cnt$D_IN;
	if (jumpTargets_serverAdapterB_s1$EN)
	  jumpTargets_serverAdapterB_s1 <= `BSV_ASSIGNMENT_DELAY
	      jumpTargets_serverAdapterB_s1$D_IN;
	if (pc$EN) pc <= `BSV_ASSIGNMENT_DELAY pc$D_IN;
	if (registerTarget_taggedReg$EN)
	  registerTarget_taggedReg <= `BSV_ASSIGNMENT_DELAY
	      registerTarget_taggedReg$D_IN;
	if (specPc$EN) specPc <= `BSV_ASSIGNMENT_DELAY specPc$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (waitRegTarget$EN)
	  waitRegTarget <= `BSV_ASSIGNMENT_DELAY waitRegTarget$D_IN;
      end
    if (waitRegTargetHist$EN)
      waitRegTargetHist <= `BSV_ASSIGNMENT_DELAY waitRegTargetHist$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    branchHist = 6'h2A;
    branchHistory_serverAdapterA_cnt = 3'h2;
    branchHistory_serverAdapterA_s1 = 2'h2;
    branchHistory_serverAdapterB_cnt = 3'h2;
    branchHistory_serverAdapterB_s1 = 2'h2;
    countIn = 5'h0A;
    countOut = 5'h0A;
    epoch = 3'h2;
    flushCount = 4'hA;
    issueEpoch = 3'h2;
    jumpTargets_serverAdapterA_cnt = 3'h2;
    jumpTargets_serverAdapterA_s1 = 2'h2;
    jumpTargets_serverAdapterB_cnt = 3'h2;
    jumpTargets_serverAdapterB_s1 = 2'h2;
    pc = 64'hAAAAAAAAAAAAAAAA;
    registerTarget_taggedReg = 73'h0AAAAAAAAAAAAAAAAAA;
    specPc = 64'hAAAAAAAAAAAAAAAA;
    state = 1'h0;
    waitRegTarget = 1'h0;
    waitRegTargetHist = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (branchHistory_serverAdapterA_s1[1] &&
	  !branchHistory_serverAdapterA_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N)
      if (branchHistory_serverAdapterB_s1[1] &&
	  !branchHistory_serverAdapterB_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N)
      if (jumpTargets_serverAdapterA_s1[1] &&
	  !jumpTargets_serverAdapterA_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N)
      if (jumpTargets_serverAdapterB_s1[1] &&
	  !jumpTargets_serverAdapterB_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
  end
  // synopsys translate_on
endmodule  // mkBranch

