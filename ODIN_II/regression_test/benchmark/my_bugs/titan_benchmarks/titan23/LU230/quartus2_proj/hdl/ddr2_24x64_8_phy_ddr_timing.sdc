## This file constrains the auto-calibrating memory interface
## You may need to edit the parameters at the top of this file
## to match your memory device.
## Generated by:8.0
set t(period) 3.750
set t(board_skew) 0.020
set t(DS) 0.350
set t(DH) 0.350
set t(AC) 0.500
set t(IS) 0.500
set t(IH) 0.500
set t(DSS) 0.2
set t(DSH) 0.2
set t(DQSS) 0.25
set t(DQSQ) 0.300
set t(QHS) 0.400
set t(DQSCK) 0.450
set t(capture_shift) 2.2
set t(resync_shift) 1.538
set t(HP) 1.688
if {$::TimeQuestInfo(family) == "Arria GX"} {
set t(mimic_shift) 2.200
} elseif {$::TimeQuestInfo(family) == "HardCopy II"} {
set t(mimic_shift) 2.000
} elseif {$::TimeQuestInfo(family) == "Cyclone III"} {
set t(mimic_shift) 2.500
} else {
set t(mimic_shift) 1.600
}
set t(calibration_error) 0.5
set t(additional_addresscmd_tpd) 0.000
set corename "ddr2_24x64_8_phy"
set t(inclk_period) 10.000
set t(DCD_total) 0.200
set t(PLL_PSERR) 0.000
set t(DQS_PERIOD_JITTER) 0.000
set t(DQS_PHASE_JITTER) 0.000
##
##Legal Notice: (C)2007 Altera Corporation. All rights reserved. Your
##use of Altera Corporation's design tools, logic functions and other
##software and tools, and its AMPP partner logic functions, and any
##output files any of the foregoing (including device programming or
##simulation files), and any associated documentation or information are
##expressly subject to the terms and conditions of the Altera Program
##License Subscription Agreement or other applicable license agreement,
##including, without limitation, that your use is for the sole purpose
##of programming logic devices manufactured by Altera and sold by Altera
##or its authorized distributors. Please refer to the applicable
##agreement for further details.
proc ddr_pin {n pin pins_array_name} {
  upvar 1 $pins_array_name pins
  global pins
  #puts "ddr_pin $n $pin $pins_array_name"
  if {![info exists pins($n)] } {
    post_message -type critical_warning "ddr_pin $n $pin $pins_array_name didn't recognise '$n' as a pin type"
  } else {
    lappend pins($n) $pin
  }
}
set pin_file_name "ddr2_24x64_8_phy_ddr_pins.tcl"
set dirname [file dirname [info script]] 
set fn [file join $dirname $pin_file_name]
source $fn

proc add_requirements_for_instance {corename instance_name t_name ddr2_24x64_8_phy_use_high_performance_timing} {
upvar 1 $t_name t
set instname "${instance_name}|${corename}"
global ck_output_clocks
array unset ck_output_clocks
global pins
array unset pins
set pins(ck_p) [list]
set pins(ck_n) [list]
set pins(addrcmd) [list]
set pins(addrcmd_2t) [list]
set pins(dqsgroup) [list]
set pins(dgroup) [list]

global pins_cache
if { [array exists pins_cache] &&  [info exists pins_cache($corename-$instance_name)] } {
  # post_message -type critical_warning "cache hit"
  array set pins $pins_cache($corename-$instance_name)
} else {
  # post_message -type critical_warning "cache miss"
  get_ddr_pins $instname pins
  set pins_cache($corename-$instance_name) [array get pins]
}

set msg_list [list]
set ck_pll_clock_id [get_output_clock_id $pins(ck_p) "CK output" msg_list]
if {$ck_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr2_24x64_8_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr2_24x64_8_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join $pins(ck_p)]"
} else {
  set ck_pll_clock [get_node_info -name $ck_pll_clock_id]
  set pll_ref_clk_id [get_input_clk_id $ck_pll_clock_id]
  if {$pll_ref_clk_id != -1} {
    set pll_ref_clk [get_node_info -name $pll_ref_clk_id]
    if {[get_collection_size [get_clocks -nowarn $pll_ref_clk]] == 0} {
      create_clock -period $t(inclk_period) $pll_ref_clk
    }

    if {[get_collection_size [get_clocks -nowarn $ck_pll_clock]] > 0} {
      # PLL clocks already derived
    } else {
      derive_pll_clocks
    }
  } else {
    post_message -type info "ddr2_24x64_8_phy_ddr_timing.sdc: Could not find PLL clocks for $ck_pll_clock. Creating PLL base clocks"
    # Attempt to recover
    derive_pll_clocks -create_base_clocks
  }
  # Note that derive_clock_uncertainty -add will add the PLL jitter, SPE, and clock network jitter uncertainties during update_timing_netlist, so it can be called multiple times but will only apply uncertainties once
  derive_clock_uncertainty -add
}

set resync_clock_pattern ${instname}_alt_mem_phy_siii_*inst|clk|*|altpll_component|auto_generated|pll1|clk\[4\]
set resync_clock_id ""
sett_collection resync_clock_id [get_pins -compatibility_mode $resync_clock_pattern]
set resync_clock [get_node_info -name $resync_clock_id]
set resync_pll_ref_clk_id [get_input_clk_id $resync_clock_id]
if {$resync_pll_ref_clk_id != -1} {
  set resync_pll_ref_clk [get_node_info -name $resync_pll_ref_clk_id]
  if {[get_collection_size [get_clocks -nowarn $resync_pll_ref_clk]] == 0} {
    create_clock -period $t(inclk_period) $resync_pll_ref_clk
  }
} else {
  post_message -type warning "ddr2_24x64_8_phy_ddr_timing.sdc: Failed to find PLL input clock pin driving $resync_clock"
}
set mimic_clock_pattern ${instname}_alt_mem_phy_siii_*inst|clk|*|altpll_component|auto_generated|pll1|clk\[5\]
set mimic_clock_pins [get_pins -nowarn -compatibility_mode $mimic_clock_pattern]
if {[get_collection_size $mimic_clock_pins] == 1} {
  set mimic_clock_id ""
  sett_collection mimic_clock_id $mimic_clock_pins
  set mimic_clock [get_node_info -name $mimic_clock_id]
  # Cut the path from the mimic pin to the mimic clock
  set_false_path -from [get_ports $pins(ck_p)] -to [get_clocks $mimic_clock]
} else {
  set mimic_clock ""
}
set system_clock_pattern ${instname}_alt_mem_phy_siii_*inst|clk|*|altpll_component|auto_generated|pll1|clk\[0\]
set system_clock_pins [get_pins -nowarn -compatibility_mode $system_clock_pattern]
if {[get_collection_size $system_clock_pins] == 1} {
  set system_clock_id ""
  sett_collection system_clock_id $system_clock_pins
  set system_clock [get_node_info -name $system_clock_id]
  if {[info exists pll_ref_clk]} {
    set_false_path -from $pll_ref_clk -to $system_clock
    set_false_path -to $pll_ref_clk -from $system_clock
  }
} else {
  set system_clock ""
}
# Stratix III.
# Not QDR datapath.
set dirname [file dirname [info script]] 
set fn [file join $dirname ${corename}_cu.tcl]
if { $::TimeQuestInfo(family) == "HardCopy II" &&  [file exists $fn]} {
  source [file join $dirname $fn]
  foreach s [list fpga_tREAD_CAPTURE_SETUP_ERROR fpga_tREAD_CAPTURE_HOLD_ERROR fpga_RESYNC_SETUP_ERROR fpga_RESYNC_HOLD_ERROR fpga_PA_DQS_SETUP_ERROR fpga_PA_DQS_HOLD_ERROR WR_DQS_DQ_SETUP_ERROR WR_DQS_DQ_HOLD_ERROR fpga_tCK_ADDR_CTRL_SETUP_ERROR fpga_tCK_ADDR_CTRL_HOLD_ERROR fpga_tDQSS_SETUP_ERROR fpga_tDQSS_HOLD_ERROR fpga_tDSSH_SETUP_ERROR fpga_tDSSH_HOLD_ERROR] {
    if { ! [info exists $s] } {
      post_message -type critical_warning "ALTMEMPHY: Missing setting in $fn:$s"
    }
  }
} else {
  if { $::TimeQuestInfo(family) == "HardCopy II" } {
    if { $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type warning "HardCopy II clock uncertainty file $fn could not be found"
    }
  }
set fpga_tREAD_CAPTURE_SETUP_ERROR 0
set fpga_tREAD_CAPTURE_HOLD_ERROR 0
set fpga_RESYNC_SETUP_ERROR 0
set fpga_RESYNC_HOLD_ERROR 0
set fpga_PA_DQS_SETUP_ERROR 0
set fpga_PA_DQS_HOLD_ERROR 0
set WR_DQS_DQ_SETUP_ERROR 0
set WR_DQS_DQ_HOLD_ERROR 0
set fpga_tCK_ADDR_CTRL_SETUP_ERROR 0
set fpga_tCK_ADDR_CTRL_HOLD_ERROR 0
set fpga_tDQSS_SETUP_ERROR 0
set fpga_tDQSS_HOLD_ERROR 0
set fpga_tDSSH_SETUP_ERROR 0
set fpga_tDSSH_HOLD_ERROR 0
}
# post_message -type info "Creating CK output clocks"
set ck_clock_types_list [list tDSS tDQSS ac_rise ac_fall]
set source $ck_pll_clock
foreach ckpin [concat $pins(ck_p) $pins(ck_n)] {
  if { [lsearch -exact $pins(ck_p) $ckpin] != -1 } { 
    set invert ""
    set ckpn p
  } elseif { [lsearch -exact $pins(ck_n) $ckpin] != -1 } {
    set invert -invert
    set ckpn n
  } else {
    error "Can't find pin $ckpin in $pins(ck_p) or $pins(ck_n)"
  }
  # We don't care about the tco of the memory clocks
  set_false_path -from * -to [get_ports $ckpin]
  set clocknamestub "${instname}_ck_${ckpn}_${ckpin}"
  foreach ck_clock_type $ck_clock_types_list {
    set clockname "${clocknamestub}_${ck_clock_type}"
    create_generated_clock -add -multiply_by 1 -source $source -master_clock $source $invert -name $clockname $ckpin
    add_output_clock $ck_clock_type $ckpn $clockname
  }
}
set scan_clock_patterns [list ${instname}_alt_mem_phy_siii_inst|clk|scan_clk|q 5]
foreach {pattern divide_by} $scan_clock_patterns {
  foreach_in_collection c [get_pins -compatibility_mode $pattern] {
set source [get_node_info -name $c]
set sys_pll_clock [get_pll_clock [list $c] "System" "" 16]
if {$sys_pll_clock != ""} {
    post_sdc_message info "Creating scan clock ${source}_clock driven by $sys_pll_clock divided by $divide_by"
    create_generated_clock -multiply_by 1 -divide_by $divide_by -source $sys_pll_clock -master_clock $sys_pll_clock $source -name ${source}_clock
  set_max_delay -to [get_clocks $sys_pll_clock] -from [get_clocks ${source}_clock] 9.0
  set_max_delay -from [get_clocks $sys_pll_clock] -to [get_clocks ${source}_clock] 9.0
  set_min_delay -to [get_clocks $sys_pll_clock] -from [get_clocks ${source}_clock] -9.0
  set_min_delay -from [get_clocks $sys_pll_clock] -to [get_clocks ${source}_clock] -9.0
} else {
  post_message -type warning "Cannot find source clock of $source"
}
  }
}
set msg_list [list]
set dqs_pll_clock_id [get_output_clock_id [get_all_dqs_pins $pins(dqsgroup)] "DQS output" msg_list]
set dq_pll_clock_id [get_output_clock_id [get_all_dq_pins $pins(dqsgroup)] "DQ output" msg_list]
if {$dqs_pll_clock_id == -1 || $dq_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr2_24x64_8_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr2_24x64_8_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join [get_all_dqs_pins $pins(dqsgroup)]]"
} else {
  set dqsclksource [get_node_info -name $dqs_pll_clock_id]
  set dqclksource [get_node_info -name $dq_pll_clock_id]
}
foreach dqsgroup $pins(dqsgroup) {
  set dqspin [lindex $dqsgroup 0]
  if {!$ddr2_24x64_8_phy_use_high_performance_timing} {
  # DQS output clock
  set dqs_out_clockname "${instname}_ddr_dqsout_${dqspin}"
  create_generated_clock -multiply_by 1 -source $dqsclksource -master_clock $dqsclksource $dqspin -name $dqs_out_clockname -add
  }
  # endif !ddr2_24x64_8_phy_use_high_performance_timing
  # DQS input clock
  set dqs_in_clockname "${instname}_ddr_dqsin_${dqspin}"
  create_clock -period $t(period) -name $dqs_in_clockname $dqspin -add
  if {!$ddr2_24x64_8_phy_use_high_performance_timing} {
  set_output_delay -add_delay -clock $dqs_out_clockname -max [round_3dp [expr {$t(board_skew) + $t(DS) + $WR_DQS_DQ_SETUP_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock $dqs_out_clockname -min [round_3dp [expr {-$t(DH) - $t(board_skew) - $t(DCD_total) - $WR_DQS_DQ_HOLD_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock_fall -clock $dqs_out_clockname -max [round_3dp [expr {$t(board_skew) + $t(DS) + $WR_DQS_DQ_SETUP_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock_fall -clock $dqs_out_clockname -min [round_3dp [expr {-$t(DH) - $t(board_skew) - $t(DCD_total) - $WR_DQS_DQ_HOLD_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  }
  # endif !ddr2_24x64_8_phy_use_high_performance_timing
  if {!$ddr2_24x64_8_phy_use_high_performance_timing} {
  set tDQS_PSERR 0.030
  set tDQS_PHASE_JITTER 0.045
  set uncertainty_su [expr $tDQS_PSERR + $tDQS_PHASE_JITTER]
  set uncertainty_hold [expr $tDQS_PSERR + $tDQS_PHASE_JITTER]
  set_max_delay -from [lindex $dqsgroup 2] -to * [expr {-$uncertainty_su - $fpga_tREAD_CAPTURE_SETUP_ERROR}]
  set_min_delay -from [lindex $dqsgroup 2] -to * [round_3dp [expr {-0.5 * $t(period) + $t(QHS) + $uncertainty_hold + $fpga_tREAD_CAPTURE_HOLD_ERROR}]]
  set_input_delay -add_delay -clock $dqs_in_clockname -max [round_3dp [expr {$t(DQSQ) + $t(board_skew)}]] [lindex $dqsgroup 2]
  set_input_delay -add_delay -clock $dqs_in_clockname -min [round_3dp [expr {- $t(board_skew)}]] [lindex $dqsgroup 2]
  }
  # endif !ddr2_24x64_8_phy_use_high_performance_timing
# DQS vs CK
    set off_tDQSS 0
    set off_tDSS 0
foreach ckclock [get_output_clocks tDQSS p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {($off_tDQSS+1-$t(DQSS)) * $t(period) + $t(board_skew) + $fpga_tDQSS_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {($off_tDQSS+$t(DQSS)) * $t(period) - $t(board_skew) - $fpga_tDQSS_HOLD_ERROR}]] $dqspin
}
foreach ckclock [get_output_clocks tDQSS n] {
  set_output_delay -add_delay -clock_fall -clock $ckclock -max [round_3dp [expr {($off_tDQSS+1-$t(DQSS)) * $t(period) + $t(board_skew) + $fpga_tDQSS_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock_fall -clock $ckclock -min [round_3dp [expr {($off_tDQSS+$t(DQSS)) * $t(period) - $t(board_skew) - $fpga_tDQSS_HOLD_ERROR}]] $dqspin
}
foreach ckclock [concat [get_output_clocks tDQSS p] [get_output_clocks tDQSS n]] {
  set_false_path -to [get_clocks $ckclock] -fall_from [get_clocks $dqsclksource]
}
foreach ckclock [get_output_clocks tDSS p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {($off_tDSS+$t(DSS)) * $t(period) + $t(board_skew) + $fpga_tDSSH_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {($off_tDSS-$t(DSH)) * $t(period) - $t(board_skew) - $fpga_tDSSH_HOLD_ERROR}]] $dqspin
}
foreach cknclock [get_output_clocks tDSS n] {
  set_output_delay -add_delay -clock_fall -clock $cknclock -max [round_3dp [expr {($off_tDSS+$t(DSS)) * $t(period) + $t(board_skew) + $fpga_tDSSH_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock_fall -clock $cknclock -min [round_3dp [expr {($off_tDSS-$t(DSH)) * $t(period) - $t(board_skew) - $fpga_tDSSH_HOLD_ERROR}]] $dqspin
}
foreach ckclock [concat [get_output_clocks tDSS p] [get_output_clocks tDSS n]] {
  # DSS and DSH are only for falling edge of DQS
  set_false_path -to [get_clocks $ckclock] -rise_from [get_clocks $dqsclksource]
}
# Only analyze the DDIO mux select path to the DQS output
set_false_path -from [all_registers] -to [get_ports $dqspin]
set dqsnpin [lindex $dqsgroup 3]
set_false_path -from [all_registers] -to [get_ports $dqsnpin]
  set_false_path -to [get_clocks $resync_clock] -from [get_clocks $dqs_in_clockname]
  set_false_path -from [get_clocks $resync_clock] -to [get_clocks $dqs_in_clockname]
  if {!$ddr2_24x64_8_phy_use_high_performance_timing} {
  set_false_path -to [get_clocks $resync_clock] -from [get_clocks $dqs_out_clockname]
  set_false_path -from [get_clocks $resync_clock] -to [get_clocks $dqs_out_clockname]
  set_false_path -from [get_clocks $dqclksource] -to [get_clocks $dqs_in_clockname]
  set_false_path -from [get_clocks $dqs_out_clockname] -to [get_clocks $dqs_in_clockname]
  set_false_path -from [get_clocks $dqs_in_clockname] -to [get_clocks $dqs_out_clockname]
  }
  # endif !ddr2_24x64_8_phy_use_high_performance_timing
}

if {$ddr2_24x64_8_phy_use_high_performance_timing} {
  # Cut paths to read capture registers
  set dq_list [get_all_dq_pins $pins(dqsgroup)]
  if {[llength $dq_list] > 0} {
    set_false_path -from [concat $dq_list] -to [all_registers]
  }
  # Cut paths from write registers and PLL clocks-as-data
  set d_dm_list [concat $dq_list [get_all_dm_pins $pins(dqsgroup)]]
  if {[llength $d_dm_list] > 0} {
  	set_false_path -from * -to $d_dm_list
  }
}
# endif ddr2_24x64_8_phy_use_high_performance_timing

set clear_list [list \
  ${instname}_alt_mem_phy_siii_*inst|clk|*pll|altpll_component|auto_generated|pll_lock_sync|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|global_pre_clear|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|reset_master_ams|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|*|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|clk_div_reset_ams_n_r|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|clk_div_reset_ams_n|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|pll_reconfig_reset_ams_n_r|clrn \
  ${instname}_alt_mem_phy_siii_*inst|clk|pll_reconfig_reset_ams_n|clrn \
]
foreach clear $clear_list {
  set clear_pins [get_pins -nowarn -compatibility_mode $clear]
  if {[get_collection_size $clear_pins] > 0} {
    set_false_path -thru $clear_pins -to *
  }
}
# Address Command
# post_message -type info "Address/Command"
set msg_list [list]
set ac_pll_clock_id [get_output_clock_id $pins(addrcmd) "Address/Command output" msg_list]
if {$ac_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr2_24x64_8_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr2_24x64_8_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join $pins(addrcmd)]"
} else {
  set ac_pll_clock [get_node_info -name $ac_pll_clock_id]
  set ded_off_rise 0
  set ded_off_fall 0
set off $ded_off_rise
# Only analyze the DDIO mux select
set_false_path -from [all_registers] -to [concat $pins(addrcmd) $pins(addrcmd_2t)]
foreach ckclock [get_output_clocks ac_rise p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {$off*$t(period) + $t(IS) + $t(board_skew) + $t(DCD_total) + $fpga_tCK_ADDR_CTRL_SETUP_ERROR + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {$off*$t(period) - $t(IH) - $t(board_skew) - $t(DCD_total) - $fpga_tCK_ADDR_CTRL_HOLD_ERROR  + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
}
foreach ckclock [get_output_clocks ac_rise n] {
  set_output_delay -add_delay -clock_fall -clock $ckclock -max [round_3dp [expr {$off*$t(period) + $t(IS) + $t(board_skew) + $t(DCD_total) + $fpga_tCK_ADDR_CTRL_SETUP_ERROR + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
  set_output_delay -add_delay -clock_fall -clock $ckclock -min [round_3dp [expr {$off*$t(period) - $t(IH) - $t(board_skew) - $t(DCD_total) - $fpga_tCK_ADDR_CTRL_HOLD_ERROR  + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
}
if {$ac_pll_clock_id != -1} {
  foreach ckclock [concat [get_output_clocks ac_rise p] [get_output_clocks ac_rise n]] {
    set_false_path -fall_from [get_clocks $ac_pll_clock] -to $ckclock
  }
}
}
if { [llength $pins(addrcmd_2t)] > 0 } {
  # post_message -type info "Address/Command (half rate)"
  set_multicycle_path -setup -to $pins(addrcmd_2t) 2
  set_multicycle_path -hold -to $pins(addrcmd_2t) 1
}

set mimic_clock_pattern ${instname}_alt_mem_phy_siii_*inst|clk|*|altpll_component|auto_generated|pll1|clk\[5\]
set mimic_clock_pins [get_pins -nowarn -compatibility_mode $mimic_clock_pattern]
if {[get_collection_size $mimic_clock_pins] == 1} {
  set mimic_clock [get_node_info -name $mimic_clock_id]
  foreach ckclock [concat [get_output_clocks ac_fall p] [get_output_clocks ac_rise p]] {
    set_false_path -from [get_clocks $ckclock]  -to [get_clocks $mimic_clock]
  }
  set_max_delay -from [get_clocks $mimic_clock] -to [get_clocks $system_clock] $t(period)
  set_min_delay -from [get_clocks $mimic_clock] -to [get_clocks $system_clock] -$t(period)
}
}


set instance_list [get_core_instance_list $corename]
foreach inst $instance_list {
	post_sdc_message info "Adding SDC requirements for $corename instance $inst"
	add_requirements_for_instance $corename $inst t $ddr2_24x64_8_phy_use_high_performance_timing
	add_ddr_report_command "source [list [file join [file dirname [info script]] ${corename}_report_timing.tcl]]"
}
